sourceTo("../lib/referencedata/referenceobject.r", modifiedOnly = getOption("modifiedOnlySource"), local = FALSE)
sourceTo("../transformations/transformation_functions.r", modifiedOnly = getOption("modifiedOnlySource"), local = FALSE)


################################################
#
# Generic VirtualBaseTransformation Class
#
# This is basic class defining Tranformation base
# slots and accessors
################################################


setClass(
  Class      = "VirtualBaseTransformation",
  slots = c(
    computed_colnms = "character",
    is_computed = "logical"
  ),
  prototype = list(
    is_computed = FALSE
  ),
  contains = c("VirtualReferenceObject", "VIRTUAL")
)

setGeneric("isComputed", function(object,...){standardGeneric("isComputed")})
# Returns state of the computation 
#
# Args:
#   object : object extending VirtualBaseTransformation
# Returns:
#   TRUE if computation has been performed successfuly
#   FALSE otherwise

setMethod("isComputed",
          signature(object = "VirtualBaseTransformation"),
          function(object){
            return(object@is_computed)
            
          }
)

setGeneric("setIsComputed", function(object, state = FALSE){standardGeneric("setIsComputed")})
# Sets state of the computation 
#
# Args:
#   object : object extending VirtualBaseTransformation
#   state : boolean
# Returns:
#   object : object of type VirtualBaseTransformation

setMethod("setIsComputed",
          signature(object = "VirtualBaseTransformation", state = "logical"),
          function(object, state){
            object@is_computed <- state
            return(object)
          }
)

setGeneric("getComputedVariablesNames", function(object,...){standardGeneric("getComputedVariablesNames")})
# Returns Names of the variables that are generated by computation object.
#
# Args:
#   object : object extending VirtualBaseTransformation
# Returns:
#   requiredVariablesNames

setMethod("getComputedVariablesNames",
          signature(object = "VirtualBaseTransformation"),
          function(object){
            return(object@computed_colnms)
            
          }
)



setGeneric("getOutputVariablesNames", function(object,...){standardGeneric("getOutputVariablesNames")})
# Returns Names of the variables that are generated by computation object.
#
# Args:
#   object : object extending VirtualBaseTransformation
# Returns:
#   requiredVariablesNames

setMethod("getOutputVariablesNames",
          signature(object = "VirtualBaseTransformation"),
          function(object){
            return(unique(c(getRequiredVariablesNames(object), getComputedVariablesNames(object))))
          }
)



################################################
#
# Generic VirtualTransformationComputation Class
#
# This is wrapper class wrapping computation 
# function and managing validation of variables
# for input and output
################################################

setClassUnion("TransformationOutput",c("data.frame","NULL"))
setClassUnion("TransformationInput",c("data.frame","NULL"))

setClass(
  Class = "VirtualTransformationComputation",
  slots = c(
    input = "TransformationInput",
    output = "TransformationOutput",
    compute = "function"
  ),
  prototype      = list(
    compute = pass_thru_computation
  ),
  contains = c("VirtualBaseTransformation", "VIRTUAL")
)




setGeneric("setInputData", function(object,data, ...){standardGeneric("setInputData")})
# Sets internal input datastore to new data and performs data validity checks .
#
# Args:
#   object : object of type VirtualTransformationComputation
#   data: data to store in 
# Returns:
#   Updated object with new input data.

setMethod("setInputData",
          signature(object = "VirtualTransformationComputation", data = "data.frame"),
          function(object,data){
            required_colnms <- getRequiredVariablesNames(object)
            message(paste("Updating input data in ", class(object), "object."))
            if(!has_required_columns(data, required_colnms))
            {
              message(paste("Error setting data in", class(object)))
              message(paste("Columns:",paste(colnames(data),collapse=" ")))
              message(paste("Required Columns:",paste(required_colnms,collapse=" ")))
              message(paste("Missing Columns:",paste(setdiff(required_colnms, colnames(data)),collapse=" ")))
              stop("Missing required Columns")
            } else if (nrow(data) == 0) {
              message(paste("Error setting data in", class(object)))
              stop("Incoming data has zero rows.")
            }
            
            object@input <- unique(data)
            object <- setIsComputed(object, FALSE)
            
            tryCatch ({
              validObject(object)
            }, error = function(cond){
              message(paste("Object", class(object), "became invalid after call to setInputData()", cond))
              stop("Failure when updating setting InputData")
            })
            return(object)
          }
)



setGeneric("getInputData", function(object, ...){standardGeneric("getInputData")})
# returns data.frame from internal input datastore.
#
# Args:
#   object : object of type VirtualTransformationComputation
# Returns:
#   data.frame with internal data.
setMethod("getInputData",
          signature(object = "VirtualTransformationComputation"),
          function(object){
            return(object@input)           
          }
)

setGeneric("setOutputData", function(object,data, ...){standardGeneric("setOutputData")})
# Sets internal input datastore to new data and performs data validity checks .
#
# Args:
#   object : object of type VirtualTransformationComputation
#   data: data to store in 
# Returns:
#   Updated object with new input data.

setMethod("setOutputData",
          signature(object = "VirtualTransformationComputation", data = "data.frame"),
          function(object,data){
            required_colnms <- getOutputVariablesNames(object)
            message(paste("Updating output data in ", class(object), "object."))
            if(!has_required_columns(data, required_colnms))
            {
              message(paste("Error setting data in", class(object)))
              message(paste("Columns:",paste(colnames(data),collapse=" ")))
              message(paste("Required Columns:",paste(required_colnms,collapse=" ")))
              message(paste("Missing Columns:",paste(setdiff(required_colnms, colnames(data)),collapse=" ")))
              stop("Missing required Columns")
            } else if (nrow(data) == 0) {
              message(paste("Error setting output data in", class(object)))
              stop("Incoming data has zero rows.")
            }
            
            object@output <- unique(data)
            
            tryCatch ({
              validObject(object)
            }, error = function(cond){
              message(paste("Object", class(object), "became invalid after call to setoutputData()", cond))
              stop("Failure when updating setting InputData")
            })
            return(object)
          }
)



setGeneric("getOutputData", function(object, ...){standardGeneric("getOutputData")})
# returns data.frame from internal output datastore.
#
# Args:
#   object : object of type VirtualTransformationComputation
# Returns:
#   data.frame with internal data.
setMethod("getOutputData",
          signature(object = "VirtualTransformationComputation"),
          function(object){
            return(object@output)           
          }
)

setGeneric("getComputationFunction", function(object, ...){standardGeneric("getComputationFunction")})
# returns data.frame from internal output datastore.
#
# Args:
#   object : object of type VirtualTransformationComputation
# Returns:
#   data.frame with internal data.
setMethod("getComputationFunction",
          signature(object = "VirtualTransformationComputation"),
          function(object){
            return(object@compute)           
          }
)


setGeneric("computeTransformation",function(object, ...){standardGeneric("computeTransformation")})
# triggers computation and copies computed data to output datastore.
# input has to be set using setInputData(object, data) prior to triggering 
# this function otherwise will return error
#
# Args:
#   object : object of type VirtualTransformationComputation
# Returns:
#   data.frame with internal data.
setMethod("computeTransformation",
          signature(object = "VirtualTransformationComputation"),
          function(object){
            message(paste("Triggering computation:",class(object)[[1]]))
            compute <- getComputationFunction(object)
            required_colnms <- getOutputVariablesNames(object)
            input <- getInputData(object)
            output <- tryCatch({
              compute(input)
            }, error = function(cond){
              message(paste("Error when computing",class(object)[[1]],":",cond))
            })
            
            
            if(!has_required_columns(output, required_colnms)){
              message(paste("Error when computing",class(object)[[1]]))
              message(paste("Columns:",paste(colnames(output),collapse=" ")))
              message(paste("Required Columns:",paste(required_colnms,collapse=" ")))
              message(paste("Missing Columns:",paste(setdiff(required_colnms, colnames(output)),collapse=" ")))
              stop("Missing required Columns from computation result")

            } else if(nrow(output) != nrow(input)){
              message(paste("Error when computing",class(object)[[1]]))
              message(paste("Output data has different number of rows that input."))
              message(paste("Output number of rows:",paste(nrow(output),collapse=" ")))
              message(paste("Input number of rows:",paste(nrow(input),collapse=" ")))
              stop("Computation result has wrong number of rows")
              
            }  
            else{
              object <- setIsComputed(object, TRUE)
              object <- setOutputData(object,output)
              
            }
            return(object)
          }
)


################################################
#
#  TestTransformationComputation Classes
#
# These are only for test purposes
################################################
setClass(
  Class = "TestTransformationComputation",
  prototype      = list(
    required_colnms = c("A", "B", "C")
  ),
  contains = c("VirtualTransformationComputation")
)

setClass(
  Class = "RowMeansTransformationComputation",
  prototype      = list(
    required_colnms = c("A", "B", "C"),
    compute = row_mean_computation,
    computed_colnms = "RowMean"
  ),
  contains = c("VirtualTransformationComputation")
)

setClass(
  Class = "InvalidRowMeansTransformationComputation",
  prototype      = list(
    required_colnms = c("A", "B", "C"),
    compute = pass_thru_computation,
    computed_colnms = "RowMean"
  ),
  contains = c("VirtualTransformationComputation")
)


################################################
#
# Generic VirtualTransformation Class
#
# This is adaptation class wrapping computation 
# class  and preparing computation input and 
# output for calling entity.
################################################


setClass(
  Class      = "VirtualTransformation",
  slots = c(
    computation  = "VirtualTransformationComputation"
  ),
  contains = c("VirtualBaseTransformation", "VIRTUAL")
)



setGeneric("getComputation",function(object, ...){standardGeneric("getComputation")})
# returns computation object encapsulated in Transformation .
#
# Args:
#   object : object of type VirtualTransformationComputation
# Returns:
#   computation : computation object encapsulated in Transformation of type "VirtualTransformationComputation"

setMethod("getComputation",
          signature(object = "VirtualTransformation"),
          function(object, ...){
            return(object@computation)           
          }
)




setGeneric(".setComputation",function(object, computation, ...){standardGeneric(".setComputation")})
# private method to set computation object encapsulated in Transformation .
#
# Args:
#   object : object of type VirtualTransformation
#   computation : object of type VirtualTransformationComputation
# Returns:
#   object :
setMethod(".setComputation",
          signature(object = "VirtualTransformation", computation = "VirtualTransformationComputation"),
          function(object, computation){
            object@computation <- computation
            return(object)           
          }
)



setGeneric("setComputation",function(object, computation, ...){standardGeneric("setComputation")})
# sets computation object encapsulated in Transformation .
#
# Args:
#   object : object of type VirtualTransformation
#   computation : object of type VirtualTransformationComputation
# Returns:
#   object :
setMethod("setComputation",
          signature(object = "VirtualTransformation", computation = "VirtualTransformationComputation"),
          function(object, computation){
            if(!is(computation, "VirtualTransformationComputation")){
              message(paste("Error when setting computation for",class(object)[[1]]))
              message(paste("Computation has to extend VirtualTransformationComputation class."))
              message(paste("Class of argument extends",extends(class(computation)[[1]])))
              stop("Incorrect class of computation object passed to setComputation(...)")
              
            } 
            
            # testing for required required variables
            req_comp_vars <- getRequiredVariablesNames(computation)
            req_trans_vars <- getRequiredVariablesNames(object)
            have_req_vars <- all(req_trans_vars %in% req_comp_vars)
            
            if(!have_req_vars){
              message(paste("Error when setting computation for transformation ",class(object)[[1]]))
              message(paste("Computation", class(computation)[[1]], "does not support all required Variables for transformation."))
              message(paste("Required transformation Variables :",req_trans_vars))
              message(paste("Variables supported by Computation :",req_comp_vars))
              stop("Computation has different set of required variable space than guaranteed/required by transformation.")
              
            }
            
            # testing for required output variables
            req_comp_vars <- getComputedVariablesNames(computation)
            req_trans_vars <- getComputedVariablesNames(object)
            have_req_vars <- all(req_trans_vars %in% req_comp_vars) 
            
            if(!have_req_vars){
              message(paste("Error when setting computation for transformation ",class(object)[[1]]))
              message(paste("Computation", class(computation)[[1]], "does not support all required output Variables for transformation."))
              message(paste("Required transformation Variables :",req_trans_vars))
              message(paste("Variables supported by Computation :",req_comp_vars))
              stop("Computation has different set of required output variables than guaranteed/required by transformation.")
              
            }
            
            # copying input data and storing new computation
            input <- getComputationInput(object)
            if (!is.null(input)){
              computation <- setInputData(computation, input)
            }
            
            object <- .setComputation(object, computation)
            
            tryCatch ({
              validObject(object)
            }, error = function(cond){
              message(paste("Object", class(object), "became invalid after call to setComputation()", cond))
              stop("Failure when updating setting Computation")
            })
            
            object <- setIsComputed(object,FALSE)
            
            return(object)           
          }
)

setGeneric("getComputationInput", function(object,data, ...){standardGeneric("getComputationInput")})
# returns data from internal input datastore .
#
# Args:
#   object : object of type ReferenceData
#   data: data to store in 
# Returns:
#   Updated Reference Data object with new data.

setMethod("getComputationInput",
          signature(object = "VirtualTransformation"),
          function(object){
            return(getInputData(getComputation(object)))
          }
)


setGeneric("setComputationInput", function(object,data, ...){standardGeneric("setComputationInput")})
# Sets internal datastore to new data and performs data validity checks .
#
# Args:
#   object : object of type ReferenceData
#   data: data to store in 
# Returns:
#   Updated Reference Data object with new data.

setMethod("setComputationInput",
          signature(object = "VirtualTransformation", data = "data.frame"),
          function(object,data){
            required_colnms <- getRequiredVariablesNames(object)
            message(paste("Updating", class(object), "object."))
            if(!has_required_columns(data, required_colnms))
            {
              message(paste("Error setting computation data in", class(object)))
              message(paste("Columns:",paste(colnames(data),collapse=" ")))
              message(paste("Required Columns:",paste(required_colnms,collapse=" ")))
              message(paste("Missing Columns:",paste(setdiff(required_colnms, colnames(data)),collapse=" ")))
              stop("Missing required Columns")
            }  else if (nrow(data) == 0) {
              message(paste("Error setting data in", class(object)))
              stop("Incoming data has zero rows in setComputationInput().")
            }
            
            comp <- getComputation(object)
            comp <- setInputData(comp, data)
            object <- .setComputation(object, comp)
            object <- setIsComputed(object,FALSE)
            
            tryCatch ({
              validObject(object)
            }, error = function(cond){
              message(paste("Object", class(object), "became invalid after call to setComputationInput()", cond))
              stop("Failure when updating setting ComputationInput")
            })
            
            return(object)
          }
)


setGeneric("triggerComputation",function(object, force = FALSE, ...){standardGeneric("triggerComputation")})
setMethod("triggerComputation",
          signature(object = "VirtualTransformation"),
          function(object, force = FALSE ){
            #Need to have updated the TransormationComputation data first if this is relevant
            #Not implemented in the virtual function because it could adopt various forms
            if (isComputed(object) && force == FALSE) {
              message(paste("Computation already done for :",class(object)[[1]]))
              message(paste("Skipping ... "))
              message(paste("Please set triggerComputation(obje, force = TRUE) to force recalculation "))
              return(object)
            }
            
            message(paste("Triggering Transformation computation:",class(object)[[1]]))
            cmpt <- tryCatch({
              comp <- getComputation(object)
              comp <- computeTransformation(comp)
            }, error = function(cond){
              message(paste("Error when computing Transformation",class(object)[[1]],":",cond))
              stop("Failure when running computeTransformation(comp) in triggerComputation().")
              
            })
            if(isComputed(comp)){
              object <- .setComputation(object,comp)
              object <- setIsComputed(object, TRUE)
            } 
            else{
              message(paste("Error when computing Transformation",class(object)[[1]]))
              message(paste("Computation",class(comp)[[1]], "Did not produce any result."))
              stop("Computation did not produce any result in triggerComputation().")
            }
            return(object)
          }
)

setGeneric("getComputationOutput",function(object){standardGeneric("getComputationOutput")})
setMethod("getComputationOutput",
          signature(object = "VirtualTransformation"),
          function(object){
            if (!isComputed(object)) {
              message(paste("Error when calling getComputationOutput on",class(object)[[1]]))
              message(paste("Computation hasn't been triggered use triggerComputation() before requesting Output."))
              stop("Computation hasn't been triggered.).")
              
            } else {
              return(getOutputData(getComputation(object)))  
            }
          }
)


################################################
#
#  TestTransformation Classes
#
# These are only for test purposes
################################################
setClass(
  Class = "TestTransformation",
  prototype      = list(
    required_colnms = c("A", "B", "C"),
    computation = new("TestTransformationComputation")
  ),
  contains = c("VirtualTransformation")
)


setClass(
  Class = "RowMeansTransformation",
  prototype      = list(
    required_colnms = c("A", "B", "C"),
    computed_colnms = c("RowMean"),
        computation = new("RowMeansTransformationComputation")
  ),
  contains = c("VirtualTransformation")
)

setClass(
  Class = "InvalidRowMeansTransformation",
  prototype      = list(
    required_colnms = c("A", "B", "C"),
    computed_colnms = c("RowMean"),
    computation = new("InvalidRowMeansTransformationComputation")
  ),
  contains = c("VirtualTransformation")
)
